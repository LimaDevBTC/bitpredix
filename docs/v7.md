# BITPREDIX v7 — Especificacao Tecnica e Guia de Implementacao

> Este documento contem TUDO que e necessario para implementar o v7 em uma janela
> de contexto nova, sem precisar ler outros arquivos alem dos indicados.

---

## 1. CONTEXTO E MOTIVACAO

BitPredix e um mercado preditivo on-chain (Stacks blockchain, testnet) onde usuarios
apostam se o preco do BTC/USD vai subir ou descer em rounds de 60 segundos.

O contrato ativo e `bitpredix-v6`. Smart contracts no Stacks sao **imutaveis** apos
deploy, entao criamos `bitpredix-v7` como novo contrato com 3 mudancas:

| # | Mudanca | Problema no v6 |
|---|---------|----------------|
| 1 | Cutoff 5s + assert on-chain | `TRADING_WINDOW u48` fecha 12s antes; assert ausente no `place-bet` |
| 2 | Resolucao automatica de rounds | Rounds so resolvem quando user faz claim manualmente |
| 3 | Auto-claim via backend | Cada user precisa clicar claim e pagar gas individualmente |

**Deployer**: `ST1QPMHMXY9GW7YF5MA9PDD84G3BGV0SSJ74XS9EK`
**Token**: `.test-usdcx` (SIP-010, 6 decimais, approve/transfer-from)

---

## 2. ARQUITETURA POS-V7

```
┌─────────────┐     place-bet()         ┌──────────────────┐
│   Usuario    │ ──────────────────────> │                  │
│  (frontend)  │                         │  bitpredix-v7    │
│              │ <── claim-round-side()  │  (smart contract)│
│              │     (fallback manual)   │                  │
└─────────────┘                         └────────┬─────────┘
                                                 │
┌─────────────┐  resolve-round()                 │
│  Resolver   │  claim-on-behalf()               │
│  Daemon     │ ─────────────────────────────────┘
│  (backend)  │
│             │ ──> Pyth Benchmarks API (precos historicos)
│             │ ──> Hiro API (leitura on-chain + broadcast tx)
└─────────────┘
    Wallet do deployer paga gas de resolve + claim
```

### Fluxo de um round:
```
t=0s     Usuario aposta (place-bet)
t=0-55s  Trading aberto (TRADING_WINDOW = 55s, cutoff 5s antes do fim)
t=60s    Round termina
t=~65s   Daemon detecta round encerrado
t=~66s   Daemon chama resolve-round(roundId, priceStart, priceEnd)
t=~70s+  Daemon chama claim-on-behalf(user, roundId, side, ...) para cada apostador
         Payouts distribuidos automaticamente. User nao faz nada.
```

---

## 3. MUDANCA 1: CUTOFF 5s + ASSERT ON-CHAIN

### O que muda no contrato

**Constante** (linha 31 do v6):
```clarity
;; v6:
(define-constant TRADING_WINDOW u48)
;; v7:
(define-constant TRADING_WINDOW u55)  ;; Cutoff 5s — trading fecha 5s antes do fim do round
```

**Assert em `place-bet`** — adicionar dentro do `let`, apos as validacoes de side/amount:
```clarity
;; Adicionar esta variavel no bloco (let ...):
(current-time (unwrap-panic (get-stacks-block-info? time (- stacks-block-height u1))))

;; Adicionar estes asserts apos a linha (asserts! (>= amount MIN_BET) ...):
(asserts! (< current-time trading-close-time) ERR_TRADING_CLOSED)
(asserts! (not (get resolved current-round-data)) ERR_TRADING_CLOSED)
```

O cutoff de 5s (`TRADING_WINDOW = u55`) fecha o trading 5s antes do round encerrar,
oferecendo margem de seguranca contra atraso de blocos (~10s pos-Nakamoto).
O assert adicional `(not resolved)` impede apostas apos o daemon resolver o round,
fechando a janela residual entre round-end e o bloco que reflete o timestamp correto.

**Defesa em 3 camadas**:
1. Frontend desabilita botoes quando `now >= tradingClosesAt` (55s)
2. Contrato rejeita se `current-time >= trading-close-time` (assert temporal)
3. Contrato rejeita se round ja foi resolvido (assert resolved)

**Precisao temporal pos-Nakamoto**: blocos Stacks ~10s. O `get-stacks-block-info? time`
retorna timestamp do bloco anterior (~10s defasagem max). O cutoff de 5s combinado
com o assert de resolved minimiza a janela de exploracao para ~5s no pior caso.

**Nota sobre rounds futuros**: o assert `(< current-time trading-close-time)` impede
apostas em rounds passados, mas permite apostas em rounds futuros (round-id grande).
Isso nao e exploravel na pratica — o frontend so mostra o round atual, e apostar em
um round futuro nao da vantagem (precos sao determinados pelo Pyth no futuro).
Aceitavel para testnet. Para mainnet, considerar adicionar:
`(asserts! (>= current-time round-start-time) ERR_TRADING_CLOSED)`

### O que muda no frontend

**`components/MarketCardV4.tsx` linha 24:**
```typescript
// DE:
const TRADING_WINDOW_MS = 48 * 1000  // Trading fecha 12s antes do fim
// PARA:
const TRADING_WINDOW_MS = 55 * 1000  // Trading fecha 5s antes do fim do round
```

**`app/api/round/route.ts` linha 84:**
```typescript
// DE:
tradingClosesAt: startAt + 48 * 1000,
// PARA:
tradingClosesAt: startAt + 55 * 1000,
```

---

## 4. MUDANCA 2: RESOLUCAO AUTOMATICA

### Nova funcao publica: `resolve-round`

```clarity
(define-public (resolve-round (round-id uint) (price-start uint) (price-end uint))
  (let (
    (round-end-time (* (+ round-id u1) ROUND_DURATION))
    (current-time (unwrap-panic (get-stacks-block-info? time (- stacks-block-height u1))))
    (round-data (default-to
      { total-up: u0, total-down: u0, price-start: u0, price-end: u0, resolved: false }
      (map-get? rounds { round-id: round-id })))
  )
    ;; Apenas deployer ou apostador pode resolver
    (asserts! (or
      (is-eq tx-sender DEPLOYER)
      (is-some (map-get? bets { round-id: round-id, user: tx-sender, side: "UP" }))
      (is-some (map-get? bets { round-id: round-id, user: tx-sender, side: "DOWN" }))
    ) ERR_UNAUTHORIZED)
    ;; Round deve ter terminado
    (asserts! (> current-time round-end-time) ERR_ROUND_NOT_ENDED)
    ;; Precos validos
    (asserts! (> price-start u0) ERR_INVALID_PRICES)
    (asserts! (> price-end u0) ERR_INVALID_PRICES)
    ;; Nao pode resolver duas vezes
    (asserts! (not (get resolved round-data)) ERR_ALREADY_RESOLVED)

    ;; Seta precos e marca como resolvido
    (map-set rounds { round-id: round-id }
      (merge round-data { price-start: price-start, price-end: price-end, resolved: true }))

    (ok { round-id: round-id,
          outcome: (if (> price-end price-start) "UP" "DOWN"),
          price-start: price-start,
          price-end: price-end })
  )
)
```

**Posicao no arquivo**: inserir APOS `claim-round-side` (que termina na linha 238 do v6)
e ANTES da secao read-only.

### Nova constante necessaria: `DEPLOYER`
```clarity
;; Adicionar apos a linha 16 (SELF):
(define-constant DEPLOYER 'ST1QPMHMXY9GW7YF5MA9PDD84G3BGV0SSJ74XS9EK)
```
Principal explicito para auth (diferente de CONTRACT_OWNER que e `tx-sender` no deploy).

### Novo erro: `ERR_ALREADY_RESOLVED`
```clarity
;; Adicionar apos ERR_INVALID_PRICES (linha 27):
(define-constant ERR_ALREADY_RESOLVED (err u1012))
```

---

## 5. MUDANCA 3: AUTO-CLAIM VIA BACKEND

### 5.1 Novo map: `round-bettors`

Rastreia todos os apostadores unicos de cada round:

```clarity
;; Adicionar apos user-pending-rounds (linha 65):

;; Lista de apostadores por round (para backend auto-claim)
(define-map round-bettors
  { round-id: uint }
  { bettors: (list 200 principal) }
)
```

### 5.2 Nova private: `add-bettor-to-round`

Mesmo padrao de `add-user-pending-round` com `index-of?` para deduplicacao.
**IMPORTANTE**: retorna `bool`, nao `response`. Nunca falha — se lista cheia,
retorna `true` silenciosamente (a aposta NAO e bloqueada).

```clarity
;; Adicionar na secao FUNCOES PRIVADAS (apos remove-user-pending-round):

(define-private (add-bettor-to-round (round-id uint) (bettor principal))
  (let (
    (current-data (default-to { bettors: (list ) } (map-get? round-bettors { round-id: round-id })))
    (current-list (get bettors current-data))
  )
    (if (is-some (index-of? current-list bettor))
      true
      (match (as-max-len? (append current-list bettor) u200)
        new-list (begin
          (map-set round-bettors { round-id: round-id } { bettors: new-list })
          true)
        true
      )
    )
  )
)
```

### 5.3 Chamar `add-bettor-to-round` em `place-bet`

Adicionar **antes** do `(ok ...)` final em `place-bet`:
```clarity
    ;; Adiciona bettor a lista do round (para auto-claim)
    (add-bettor-to-round round-id tx-sender)

    (ok { ... })
```

### 5.4 Nova funcao publica: `claim-on-behalf`

Mesma logica de `claim-round-side` mas:
- Recebe `user` como parametro (nao usa `tx-sender` para lookup)
- So DEPLOYER pode chamar
- Resolve round implicitamente se necessario (safety net)
- Payout vai para `user`, nao para `tx-sender`

```clarity
;; Adicionar apos resolve-round:

;; Claim em nome de um usuario (chamado pelo backend/deployer)
;; Apenas DEPLOYER pode chamar. Payout vai para o usuario, deployer paga gas.
(define-public (claim-on-behalf (user principal) (round-id uint) (side (string-ascii 4)) (price-start uint) (price-end uint))
  (let (
    (round-data (default-to
      { total-up: u0, total-down: u0, price-start: u0, price-end: u0, resolved: false }
      (map-get? rounds { round-id: round-id })))
    (bet-data (unwrap! (map-get? bets { round-id: round-id, user: user, side: side }) ERR_NO_BET))
  )
    ;; Apenas deployer pode chamar
    (asserts! (is-eq tx-sender DEPLOYER) ERR_UNAUTHORIZED)
    ;; Validacoes
    (asserts! (or (is-eq side "UP") (is-eq side "DOWN")) ERR_INVALID_SIDE)
    (asserts! (not (get claimed bet-data)) ERR_ALREADY_CLAIMED)
    (asserts! (> price-start u0) ERR_INVALID_PRICES)
    (asserts! (> price-end u0) ERR_INVALID_PRICES)

    ;; Resolve o round se ainda nao foi resolvido (safety net)
    (if (not (get resolved round-data))
      (map-set rounds { round-id: round-id }
        (merge round-data { price-start: price-start, price-end: price-end, resolved: true }))
      true
    )

    ;; Busca dados atualizados do round
    (let (
      (final-round (unwrap-panic (map-get? rounds { round-id: round-id })))
      (final-price-start (get price-start final-round))
      (final-price-end (get price-end final-round))
      (outcome (if (> final-price-end final-price-start) "UP" "DOWN"))
      (user-won (is-eq side outcome))
      (total-pool (+ (get total-up final-round) (get total-down final-round)))
      (winning-pool (if (is-eq outcome "UP")
        (get total-up final-round)
        (get total-down final-round)))
      (user-amount (get amount bet-data))
    )
      ;; Marca aposta como claimed
      (map-set bets { round-id: round-id, user: user, side: side }
        (merge bet-data { claimed: true }))

      ;; Remove da lista de pendentes se ambos os lados ja foram claimed
      (let (
        (other-side (if (is-eq side "UP") "DOWN" "UP"))
        (other-bet (map-get? bets { round-id: round-id, user: user, side: other-side }))
        (other-claimed (match other-bet ob (get claimed ob) true))
      )
        (if other-claimed
          (begin (remove-user-pending-round user round-id) true)
          true
        )
      )

      ;; Calcula e paga se ganhou
      (if user-won
        (if (> winning-pool u0)
          (let (
            (gross-payout (/ (* user-amount total-pool) winning-pool))
            (fee (/ (* gross-payout FEE_BPS) u10000))
            (net-payout (- gross-payout fee))
          )
            (try! (contract-call? .test-usdcx transfer-from SELF user net-payout none))
            (if (> fee u0)
              (try! (contract-call? .test-usdcx transfer-from SELF FEE_RECIPIENT fee none))
              true
            )
            (ok { won: true, payout: net-payout, outcome: outcome,
                  price-start: final-price-start, price-end: final-price-end })
          )
          (begin
            (try! (contract-call? .test-usdcx transfer-from SELF user user-amount none))
            (ok { won: true, payout: user-amount, outcome: outcome,
                  price-start: final-price-start, price-end: final-price-end })
          )
        )
        (ok { won: false, payout: u0, outcome: outcome,
              price-start: final-price-start, price-end: final-price-end })
      )
    )
  )
)
```

### 5.5 Seguranca do `transfer-from` em `claim-on-behalf`

Quando bitpredix-v7 chama `test-usdcx.transfer-from(SELF, user, amount)`:
- No contexto de `test-usdcx`: `contract-caller` = bitpredix-v7 (o contrato que chamou)
- `from` = SELF = bitpredix-v7
- Linha 52 de `test-usdcx.clar`: `(if (is-eq from spender)` → `from == contract-caller` → TRUE
- Resultado: permite transfer SEM allowance (escrow do proprio contrato)
- Funciona igualmente se `tx-sender` e user (claim-round-side) ou deployer (claim-on-behalf)

### 5.6 Nova read-only: `get-round-bettors`

```clarity
;; Adicionar na secao READ-ONLY:

(define-read-only (get-round-bettors (round-id uint))
  (default-to { bettors: (list ) }
    (map-get? round-bettors { round-id: round-id }))
)
```

### 5.7 `claim-round-side` — mantido sem alteracoes

Funciona como fallback manual se o daemon falhar. Mesma assinatura e logica do v6.

---

## 6. CONTRATO v7 — RECEITA COMPLETA (DIFF DO v6)

Para criar `contracts/bitpredix-v7.clar`, copiar `contracts/bitpredix-v6.clar` e aplicar:

### 6.1 Header (linhas 1-9)
Substituir bloco de comentarios:
```clarity
;; ============================================================================
;; BITPREDIX v7 - Prediction Market (Beta/Testnet)
;; ============================================================================
;; Mudancas vs v6:
;; - Cutoff 5s (TRADING_WINDOW u55) com validacao on-chain em place-bet
;; - resolve-round: resolucao automatica de rounds (deployer ou apostador)
;; - claim-on-behalf: auto-claim via backend (apenas deployer)
;; - round-bettors: tracking de apostadores por round para auto-claim
;; ============================================================================
```

### 6.2 SELF (linha 16)
```clarity
;; DE:
(define-constant SELF 'ST1QPMHMXY9GW7YF5MA9PDD84G3BGV0SSJ74XS9EK.bitpredix-v6)
;; PARA:
(define-constant SELF 'ST1QPMHMXY9GW7YF5MA9PDD84G3BGV0SSJ74XS9EK.bitpredix-v7)
```

### 6.3 Adicionar DEPLOYER (apos SELF)
```clarity
(define-constant DEPLOYER 'ST1QPMHMXY9GW7YF5MA9PDD84G3BGV0SSJ74XS9EK)
```

### 6.4 Adicionar ERR_ALREADY_RESOLVED (apos ERR_INVALID_PRICES)
```clarity
(define-constant ERR_ALREADY_RESOLVED (err u1012))
```

### 6.5 TRADING_WINDOW (linha 31)
```clarity
;; DE:
(define-constant TRADING_WINDOW u48)
;; PARA:
(define-constant TRADING_WINDOW u55)
```

### 6.6 Adicionar map round-bettors (apos user-pending-rounds, linha 65)
```clarity
(define-map round-bettors
  { round-id: uint }
  { bettors: (list 200 principal) }
)
```

### 6.7 place-bet — 4 mudancas

**6.7a** Adicionar `current-time` no `let` (apos `trading-close-time`):
```clarity
    (current-time (unwrap-panic (get-stacks-block-info? time (- stacks-block-height u1))))
```

**6.7b** Adicionar asserts (apos `asserts! >= amount MIN_BET`):
```clarity
    ;; Validacao on-chain: impede apostas em rounds ja encerrados
    (asserts! (< current-time trading-close-time) ERR_TRADING_CLOSED)
    ;; Impede apostas em rounds ja resolvidos (fecha janela residual de atraso de bloco)
    (asserts! (not (get resolved current-round-data)) ERR_TRADING_CLOSED)
```

**6.7c** Adicionar `add-bettor-to-round` (apos `add-user-pending-round`, antes do `(ok ...)`):
```clarity
    ;; Adiciona bettor a lista do round (para auto-claim)
    (add-bettor-to-round round-id tx-sender)
```

### 6.8 Adicionar resolve-round (apos claim-round-side, antes da secao READ-ONLY)
Ver secao 4 deste doc para o codigo completo.

### 6.9 Adicionar claim-on-behalf (apos resolve-round)
Ver secao 5.4 deste doc para o codigo completo.

### 6.10 Adicionar get-round-bettors (na secao READ-ONLY)
Ver secao 5.6 deste doc.

### 6.11 Adicionar add-bettor-to-round (na secao FUNCOES PRIVADAS)
Ver secao 5.2 deste doc.

### 6.12 claim-round-side — nenhuma alteracao

---

## 7. SCRIPT DE DEPLOY: `scripts/deploy-bitpredix-v7.mjs`

Copiar `scripts/deploy-bitpredix-v6.mjs` e alterar apenas:

```javascript
// Linha 27:
const CONTRACT_NAME = 'bitpredix-v7'
// Linha 28:
const CONTRACT_PATH = './contracts/bitpredix-v7.clar'
```

E atualizar o log na linha 41:
```javascript
console.log('Deploying bitpredix-v7 to Stacks testnet...\n')
```

E o tmpFile na linha 91:
```javascript
const tmpFile = '/tmp/stx-deploy-v7-tx.bin'
```

Uso: `ORACLE_MNEMONIC="..." node scripts/deploy-bitpredix-v7.mjs`

---

## 8. RESOLVER DAEMON: `scripts/resolver-daemon.mjs`

Script standalone Node.js que roda em loop continuo. Usa a wallet do deployer
para resolver rounds e fazer claim em nome de todos os apostadores.

### 8.1 Dependencias (ja instaladas no projeto)
```javascript
import txPkg from '@stacks/transactions'
const { makeContractCall, AnchorMode, uintCV, stringAsciiCV,
        standardPrincipalCV, cvToHex, tupleCV, hexToCV, cvToJSON } = txPkg
import netPkg from '@stacks/network'
const { STACKS_TESTNET } = netPkg
import walletPkg from '@stacks/wallet-sdk'
const { generateWallet, getStxAddress } = walletPkg
```

### 8.2 Configuracao
```javascript
const MNEMONIC = process.env.ORACLE_MNEMONIC
const CONTRACT_ADDRESS = 'ST1QPMHMXY9GW7YF5MA9PDD84G3BGV0SSJ74XS9EK'
const CONTRACT_NAME = 'bitpredix-v7'
const HIRO_API = 'https://api.testnet.hiro.so'
const PYTH_BENCHMARKS = 'https://benchmarks.pyth.network'
const LOOP_INTERVAL_MS = 65_000  // 65 segundos (5s apos round acabar)
const TX_FEE = 50000n  // 0.05 STX por tx
```

### 8.3 Inicializacao
```javascript
// Gerar wallet a partir da mnemonic (mesmo padrao de deploy-bitpredix-v6.mjs)
const wallet = await generateWallet({ secretKey: MNEMONIC, password: '' })
const account = wallet.accounts[0]
const privateKey = account.stxPrivateKey
const address = getStxAddress({ account, network: 'testnet' })
```

### 8.4 Loop principal (a cada ~65s)

```
1. Calcular roundsToProcess:
   - Na PRIMEIRA execucao: apenas previousRoundId = Math.floor(Date.now() / 60000) - 1
   - Nas execucoes seguintes: todos os rounds desde lastProcessedRoundId + 1 ate previousRoundId
   - Isso garante catch-up se o daemon ficar offline por varios minutos
   - Manter variavel lastProcessedRoundId para tracking

2. Para cada roundId em roundsToProcess:

   2a. Ler round on-chain:
       POST https://api.testnet.hiro.so/v2/map_entry/{addr}/{name}/rounds
       Body: cvToHex(tupleCV({ 'round-id': uintCV(roundId) }))
       - Se round nao existe ou total-up + total-down = 0 → skip (round vazio)

   2b. Buscar precos do Pyth Benchmarks (se round NAO resolvido):
       GET https://benchmarks.pyth.network/v1/shims/tradingview/history
           ?symbol=Crypto.BTC/USD&resolution=1
           &from={roundStartTimestamp - 120}&to={roundEndTimestamp + 120}
       ATENCAO: resposta do Pyth usa chaves de 1 letra: { t: [], o: [], c: [] }
       (diferente do frontend que usa { timestamps, open, close } via proxy)
       - Encontrar candle mais proximo do inicio e fim do round
         (mesma logica de lib/pyth.ts findClosestCandleIndex)
       - Se mesmo candle: priceStart = open, priceEnd = close
       - Se candles diferentes: priceStart = close[startIdx], priceEnd = close[endIdx]
       - Converter para centavos: Math.round(price * 100)

   2c. Resolver round (se NAO resolvido):
       - makeContractCall com functionName: 'resolve-round'
       - functionArgs: [uintCV(roundId), uintCV(priceStart), uintCV(priceEnd)]
       - Broadcast via POST /v2/transactions (binary, mesmo padrao do deploy)
       - Esperar tx no mempool (poll /extended/v1/tx/{txId} a cada 2.5s, max 30s)
       - nonce++

   2d. Se round JA resolvido (step 2a), ler precos do round on-chain:
       - priceStart = round-data.price-start
       - priceEnd = round-data.price-end
       (nao precisa buscar Pyth — precos ja estao travados on-chain)

   2e. Ler lista de apostadores:
       Chamar read-only get-round-bettors(roundId) via
       POST /v2/contracts/call-read/{addr}/{name}/get-round-bettors
       - Parsear lista de principals

   2f. Para cada apostador:
       i. Chamar read-only get-user-bets(roundId, bettor):
          POST /v2/contracts/call-read/{addr}/{name}/get-user-bets
          - Retorna { up: optional{amount,claimed}, down: optional{amount,claimed} }
       ii. Para cada side que existe e claimed = false:
           - Enviar tx claim-on-behalf(bettor, roundId, side, priceStart, priceEnd)
           - Esperar tx no mempool antes da proxima
           - nonce++

3. Atualizar lastProcessedRoundId = max(roundsToProcess)
```

### 8.5 Gestao de nonce

Buscar nonce antes de cada batch:
```javascript
const nonceData = await fetch(`${HIRO_API}/extended/v1/address/${address}/nonces`).then(r => r.json())
let nonce = nonceData.possible_next_nonce
```
Incrementar localmente (`nonce++`) para cada tx no batch. NAO re-buscar entre txs do
mesmo batch (causa nonce collision se a tx anterior ainda nao propagou).

### 8.6 Broadcast de transacao

Usar o mesmo padrao do deploy script:
```javascript
const tx = await makeContractCall({
  contractAddress: CONTRACT_ADDRESS,
  contractName: CONTRACT_NAME,
  functionName,
  functionArgs,
  senderKey: privateKey,
  network: STACKS_TESTNET,
  anchorMode: AnchorMode.Any,
  fee: TX_FEE,
  nonce: BigInt(nonce),
})
const hexTx = tx.serialize()
const binaryTx = Buffer.from(hexTx, 'hex')
// Broadcast via curl ou fetch para /v2/transactions com Content-Type: application/octet-stream
```

### 8.7 Leitura de dados on-chain (read-only calls)

Para ler maps (rounds, round-bettors):
```javascript
// Map entry
const keyHex = cvToHex(tupleCV({ 'round-id': uintCV(roundId) }))
const res = await fetch(`${HIRO_API}/v2/map_entry/${CONTRACT_ADDRESS}/${CONTRACT_NAME}/rounds?proof=0`, {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify(keyHex)
})
```

Para chamar read-only functions:
```javascript
const res = await fetch(`${HIRO_API}/v2/contracts/call-read/${CONTRACT_ADDRESS}/${CONTRACT_NAME}/${functionName}`, {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({
    sender: CONTRACT_ADDRESS,
    arguments: [cvToHex(uintCV(roundId)), cvToHex(standardPrincipalCV(bettor))]
  })
})
const data = await res.json()
// data.result e hex-encoded CV — decodificar com hexToCV + cvToJSON
```

### 8.8 Monitoramento
- Log STX balance a cada tick
- Warning se balance < 50 STX
- Log de cada tx enviada com txId

### 8.9 Custos estimados
- 1 resolve-round + N claim-on-behalf por round
- Com 10 apostadores: ~0.55 STX/round → ~792 STX/dia
- Testnet: faucet disponivel para repor

---

## 9. MUDANCAS NO FRONTEND

### 9.1 `components/MarketCardV4.tsx`
**Linha 24** — mudar TRADING_WINDOW_MS:
```typescript
const TRADING_WINDOW_MS = 55 * 1000  // Trading fecha 5s antes do fim do round
```
Nenhuma outra mudanca necessaria. O `canTrade`, `isTradingOpen`, `requestBet` ja usam
essa constante corretamente.

### 9.2 `app/api/round/route.ts`
**Linha 84** — mudar tradingClosesAt:
```typescript
tradingClosesAt: startAt + 55 * 1000,
```

### 9.3 `.env.local`
```
NEXT_PUBLIC_BITPREDIX_CONTRACT_ID=ST1QPMHMXY9GW7YF5MA9PDD84G3BGV0SSJ74XS9EK.bitpredix-v7
```

### 9.4 `package.json`
Adicionar na secao `"scripts"`:
```json
"resolver-daemon": "node scripts/resolver-daemon.mjs"
```

### 9.5 `components/ClaimButton.tsx`
**Nenhuma mudanca de codigo.** O contrato e lido de `NEXT_PUBLIC_BITPREDIX_CONTRACT_ID`
(.env.local), que apontara para v7. A funcao `claim-round-side` continua existindo
no v7 com mesma assinatura.

---

## 10. INVENTARIO COMPLETO DO CONTRATO v7

### Constantes

| Nome | Valor | Mudou? |
|------|-------|--------|
| `CONTRACT_OWNER` | `tx-sender` | Nao |
| `SELF` | `deployer.bitpredix-v7` | Sim (era v6) |
| `DEPLOYER` | `ST1QPM...S9EK` | **NOVO** |
| `ERR_UNAUTHORIZED` | `u1000` | Nao |
| `ERR_ROUND_NOT_ENDED` | `u1001` | Nao |
| `ERR_NO_BET` | `u1002` | Nao |
| `ERR_ALREADY_CLAIMED` | `u1003` | Nao |
| `ERR_INVALID_SIDE` | `u1004` | Nao |
| `ERR_INVALID_AMOUNT` | `u1005` | Nao |
| `ERR_TRADING_CLOSED` | `u1006` | Nao |
| `ERR_TRANSFER_FAILED` | `u1007` | Nao |
| `ERR_INVALID_PRICES` | `u1009` | Nao |
| `ERR_ALREADY_RESOLVED` | `u1012` | **NOVO** |
| `ROUND_DURATION` | `u60` | Nao |
| `TRADING_WINDOW` | `u55` | Sim (era u48) |
| `MIN_BET` | `u1000000` | Nao |
| `FEE_BPS` | `u300` | Nao |
| `FEE_RECIPIENT` | `ST1QPM...S9EK` | Nao |

### Maps

| Nome | Key | Value | Novo? |
|------|-----|-------|-------|
| `rounds` | `{ round-id: uint }` | `{ total-up, total-down, price-start, price-end, resolved }` | Nao |
| `bets` | `{ round-id, user, side }` | `{ amount, claimed }` | Nao |
| `user-pending-rounds` | `{ user }` | `{ round-ids: (list 50 uint) }` | Nao |
| `round-bettors` | `{ round-id }` | `{ bettors: (list 200 principal) }` | **SIM** |

### Funcoes Publicas

| Funcao | Params | Quem chama | Nova? |
|--------|--------|------------|-------|
| `place-bet` | `(round-id, side, amount)` | Qualquer user | Modificada (assert + add-bettor) |
| `claim-round-side` | `(round-id, side, price-start, price-end)` | User que apostou | Nao |
| `resolve-round` | `(round-id, price-start, price-end)` | DEPLOYER ou apostador | **SIM** |
| `claim-on-behalf` | `(user, round-id, side, price-start, price-end)` | Apenas DEPLOYER | **SIM** |

### Funcoes Read-Only

| Funcao | Params | Retorno | Nova? |
|--------|--------|---------|-------|
| `get-current-round-id` | — | `uint` | Nao |
| `get-round` | `(round-id)` | `optional{...}` | Nao |
| `get-bet` | `(round-id, user, side)` | `optional{amount,claimed}` | Nao |
| `get-user-bets` | `(round-id, user)` | `{up, down}` | Nao |
| `get-user-pending-rounds` | `(user)` | `{round-ids}` | Nao |
| `get-pending-count` | `(user)` | `uint` | Nao |
| `is-round-ended` | `(round-id)` | `bool` | Nao |
| `is-trading-open` | `(round-id)` | `bool` | Nao |
| `get-round-bettors` | `(round-id)` | `{bettors}` | **SIM** |

### Funcoes Privadas

| Funcao | Params | Nova? |
|--------|--------|-------|
| `is-not-target-round` | `(id)` | Nao |
| `add-user-pending-round` | `(user, round-id)` | Nao |
| `remove-user-pending-round` | `(user, round-id)` | Nao |
| `add-bettor-to-round` | `(round-id, bettor)` | **SIM** |

### Data Vars

| Nome | Tipo | Valor Inicial | Nova? |
|------|------|---------------|-------|
| `filter-target-round` | `uint` | `u0` | Nao |

---

## 11. ARQUIVOS A CRIAR/MODIFICAR

| Arquivo | Acao | Descricao |
|---------|------|-----------|
| `contracts/bitpredix-v7.clar` | **CRIAR** | Copia v6 + todas mudancas da secao 6 |
| `scripts/deploy-bitpredix-v7.mjs` | **CRIAR** | Copia deploy-v6, muda nome/path |
| `scripts/resolver-daemon.mjs` | **CRIAR** | Backend auto-resolver + auto-claim |
| `components/MarketCardV4.tsx` | EDITAR | Linha 24: `48 * 1000` → `60 * 1000` |
| `app/api/round/route.ts` | EDITAR | Linha 84: `48 * 1000` → `60 * 1000` |
| `.env.local` | EDITAR | Contract ID → `bitpredix-v7` |
| `package.json` | EDITAR | Novo script `resolver-daemon` |

---

## 12. DEPLOY E TESTE

### Sequencia
1. Criar `contracts/bitpredix-v7.clar`
2. Validar: `clarinet check`
3. Criar `scripts/deploy-bitpredix-v7.mjs`
4. Deploy: `ORACLE_MNEMONIC="..." node scripts/deploy-bitpredix-v7.mjs`
5. Aguardar confirmacao (explorer: https://explorer.hiro.so)
6. Atualizar `.env.local` com novo contract ID
7. Editar frontend (MarketCardV4.tsx, round/route.ts)
8. Criar `scripts/resolver-daemon.mjs`
9. Testar manualmente pelo app
10. Iniciar daemon: `ORACLE_MNEMONIC="..." npm run resolver-daemon`

### Checklist de testes
- [ ] Apostar UP — funciona ate 55s do round
- [ ] Apostar apos 55s — falha com ERR_TRADING_CLOSED (u1006)
- [ ] Apostar em round ja resolvido — falha com ERR_TRADING_CLOSED (u1006)
- [ ] Apostar UP + UP — acumula valor
- [ ] Apostar UP + DOWN — coexistem (hedging)
- [ ] resolve-round por deployer — seta precos, resolved: true
- [ ] resolve-round por apostador — funciona
- [ ] resolve-round por nao-apostador — falha com ERR_UNAUTHORIZED (u1000)
- [ ] resolve-round em round nao-encerrado — falha com ERR_ROUND_NOT_ENDED (u1001)
- [ ] resolve-round em round ja resolvido — falha com ERR_ALREADY_RESOLVED (u1012)
- [ ] claim-on-behalf por deployer — distribui payout correto
- [ ] claim-on-behalf por nao-deployer — falha com ERR_UNAUTHORIZED (u1000)
- [ ] claim-on-behalf ja claimed — falha com ERR_ALREADY_CLAIMED (u1003)
- [ ] claim-round-side manual — continua funcionando como fallback
- [ ] Resolver daemon rodando — resolve e auto-claim automaticamente
- [ ] get-round-bettors — retorna lista correta, sem duplicatas

---

## 13. NOTAS E CAVEATS

### Daemon: catch-up apos downtime
O daemon rastreia `lastProcessedRoundId`. Se ficar offline por N minutos, ao voltar
processa todos os rounds pendentes sequencialmente. Rounds muito antigos (>2h) podem
ter dados do Pyth indisponiveis — o daemon deve logar warning e pular.

### Pyth response format (daemon vs frontend)
- **Frontend** (via `/api/pyth-price` proxy): `{ timestamps: [], open: [], close: [] }`
- **Daemon** (direto do Pyth Benchmarks): `{ t: [], o: [], c: [], s: "ok" }`
O daemon deve usar as chaves de 1 letra (`t`, `o`, `c`), NAO as do frontend.

### Ordem de definicao no Clarity
Em Clarity, funcoes privadas devem ser definidas ANTES de serem chamadas.
`add-bettor-to-round` e chamada em `place-bet`, entao deve estar definida antes
de `place-bet` no arquivo. Como a secao FUNCOES PRIVADAS fica no final do v6,
sera necessario mover `add-bettor-to-round` para antes de `place-bet`, ou mover
toda a secao FUNCOES PRIVADAS para antes das FUNCOES PUBLICAS.
**Recomendacao**: reorganizar o v7 assim:
1. Constantes
2. Maps
3. Data vars
4. Funcoes privadas (incluindo add-bettor-to-round)
5. Funcoes publicas (place-bet, claim-round-side, resolve-round, claim-on-behalf)
6. Funcoes read-only

### User-pending-rounds com auto-claim
O `claim-on-behalf` remove rounds da lista `user-pending-rounds` quando ambos os
lados sao claimed. Isso significa que o ClaimButton (fallback) nao mostrara rounds
que ja foram auto-claimed. Comportamento correto.

### Edge case: preco start == preco end
Se `price-start == price-end`, o outcome e "DOWN" (porque `(> price-end price-start)`
e false). Isso e o mesmo comportamento do v6. Em um empate, DOWN ganha. Aceitavel
para testnet — empates sao extremamente raros com precos em centavos.

---

## 14. HISTORICO DE VERSOES

| Versao | Mudancas |
|--------|----------|
| v5 | Contrato base — 1 aposta por user por round, claim-round |
| v6 | Multiplas apostas (key {round-id, user, side}), acumulacao, hedging, claim-round-side |
| **v7** | **Cutoff 5s on-chain + assert resolved, resolve-round, claim-on-behalf, round-bettors, resolver daemon** |
